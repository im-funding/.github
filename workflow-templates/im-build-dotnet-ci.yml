# Workflow Code: LoathsomeSnipe_v2    DO NOT REMOVE

# TODO: Ensure each of the repo-level and env-level secrets used in this workflow have been populated by an admin in your repository.

name: .Net Core CI

on:
  # This workflow will run for the PR events:
  # opened/reopened: A PR is opened/re-opened,
  # synchronize: The PR's head branch is updated (commits pushed, the base branch changed or the head is updated from the base branch)
  # closed: A PR is merged or closed (The triggers job makes sure we only run if a merge happened, not when a close happens)
  pull_request:
    types: [opened, reopened, synchronize, closed]

env:
  DOTNET_VERSION: '' # TODO:  Add the .net version
  SOLUTION_FILE: '' # TODO:  Fill in the path and name of the solution file
  PROJECT_ROOT: '' # TODO:  Fill in the path to the folder containing the project to pre-build artifacts for, like ./src/MyBff
  DEPLOY_ZIP: 'published_app.zip'
  REPO_URL: 'https://github.com/${{ github.repository }}'
  CODE_COVERAGE_REPORT_NAME_DOTNET: '' # TODO:  Add a name for the code coverage report like '<project> Code Coverage'
  CODE_COVERAGE_CHECK_NAME_DOTNET: 'dotnet code coverage'
  CODE_COVERAGE_DIR_DOTNET: 'coverage-results/dotnet'
  CODE_COVERAGE_REPORT_NAME_JEST: '' # TODO:  Add a name for the code coverage report like '<project> Code Coverage'
  CODE_COVERAGE_CHECK_NAME_JEST: 'jest code coverage'
  CODE_COVERAGE_DIR_JEST: 'coverage-results/jest'
  JEST_TEST_DIR: '' # TODO: Add the path to dir containing the package.json file that knows how to run the jest tests.  Like ./src/MyApp.Bff/FrontEnd
  JEST_TEST_RESULTS_FILE: 'jest-results.json'
  JEST_TEST_REPORT_NAME: 'Jest Tests' # TODO: You may want to give this a more descriptive name like 'Jest Tests (MyApp FrontEnd)'

  # TODO:  Remove the following vars if not setting up a db during ci
  FLYWAY_VERSION: '' # TODO:  Add the flyway version
  DB_NAME: '' # TODO: The name of the database
  INSTALL_MOCK_DB_OBJ: '' # TODO:  [true|false] Indicates whether you want mock objects installed on the db.  Delete if not using.
  MOCK_DB_OBJ_URL: '' # TODO:  The url to the nuget feed that contains your mock db obs.  Delete if not using mock db objects.
  DROP_DB_AFTER_STEP: '' # TODO: [true|false] Indicates whether the db should be dropped after the build step

# TODO:  On the process=code-coverage-summary, process-dotnet-test-results and process-jest-test-results actions the
# create-status-check is set to true and create-pr-comment is set to false but these can be updated as desired.
# If this workflow is ran many times for a PR the create-pr-comment may become very chatty.

# TODO:  Check for the latest version of each action used

jobs:
  triggers:
    runs-on: ubuntu-latest
    outputs:
      CONTINUE_WORKFLOW: ${{ env.CONTINUE_WORKFLOW }}
      IS_MERGE_TO_MAIN: ${{ env.IS_MERGE_TO_MAIN }}
    steps:
      - run: echo "CONTINUE_WORKFLOW=true" >> $GITHUB_ENV
      - run: echo "IS_MERGE_TO_MAIN=false" >> $GITHUB_ENV

      - if: github.event.action == 'closed' && github.event.pull_request.merged == false
        run: echo "CONTINUE_WORKFLOW=false" >> $GITHUB_ENV

      - if: github.event.action == 'closed' && github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main' # TODO:  verify default branch name
        run: echo "IS_MERGE_TO_MAIN=true" >> $GITHUB_ENV

  dotnet-build-and-test:
    runs-on: [self-hosted, ubuntu-20.04] #TODO:  Switch this to [self-hosted, windows-2019] if building a db

    needs: [triggers]
    if: needs.triggers.outputs.CONTINUE_WORKFLOW == 'true'

    defaults:
      run:
        shell: bash

    outputs:
      coverage: ${{ steps.dotnet_coverage_check.outputs.coverage-outcome }}
      test: ${{ steps.dotnet_test_check.outputs.test-outcome }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2

      # TODO:  Delete the install flyway and build database steps if not building a database
      - name: Install Flyway
        uses: im-open/setup-flyway@v1.0.0
        with:
          version: ${{ env.FLYWAY_VERSION }}

      # TODO:  If you are using any nuget/npm packages from GitHub Packages uncomment this step
      # TODO:  If the project contains a local nuget.config, this action will not work properly.  Either:
      #        - Remove the file and use this action or
      #        - Delete this action and modify the file so it has the appropriate org entries in nuget.config. https://github.com/im-practices/git-er-done/blob/main/packages/connect-nuget.md#script-output
      # - name: Authenticate with GitHub Packages
      #   uses: im-open/authenticate-with-gh-package-registries@v1.0.1
      #   with:
      #     read-pkg-token: ${{ secrets.READ_PKG_TOKEN }} # This is an org-level secret
      #     orgs: '' # TODO:  Add a csv list of organizations that npm/nuget packages will be pulled from like 'im-enrollment,im-client'

      - name: Build Database
        uses: im-open/build-database-ci-action@v1.0.1
        with:
          db-server-name: localhost
          db-name: ${{ env.DB_NAME }}
          drop-db-after-build: ${{ env.DROP_DB_AFTER_STEP }}
          install-mock-db-objects: ${{ env.INSTALL_MOCK_DB_OBJ }} # TODO:  Delete if not using
          mock-db-object-nuget-feed-url: ${{ env.MOCK_DB_OBJ_URL }} # TODO:  Delete if not using

      # TODO:  Uncomment if any appsettings.json values need to change during CI, delete this step if not needed
      # - name: Update appsettings.json with Environment Specific Values
      #   uses: im-open/add-or-update-json-properties@v1.0.1
      #   with:
      #     path-to-json-file: '' #TODO:  Add file path and name to json file being updated like './src/myapp/appsettings.json'
      #     properties-to-update-or-add: |
      #       [
      #         {"SecretName": "SecretValues"},
      #         {"Nested.SecretName": "${{ secrets.NESTED_SECRET }}"},
      #         {"Auth0.ClientId": "${{ secrets.AUTH0_CLIENT_ID }}"}
      #       ]

      - name: Setup .NET Core
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      # TODO:  If config transformation is needed for different environments include environment name
      # For example to perform transformations on a web.config using the web.production.config file:
      # dotnet publish --configuration Release /p:EnvironmentName=Production
      - name: dotnet build
        run: dotnet build ${{ env.SOLUTION_FILE }} --configuration Release

      # TODO:  The test projects need a package reference to coverlet.msbuild for this to output the coverage reports correctly:
      # <PackageReference Include="coverlet.msbuild" Version="3.1.0" />
      - name: dotnet test with coverage
        continue-on-error: true
        run: dotnet test ${{ env.SOLUTION_FILE }} --logger trx --no-restore --configuration Release /property:CollectCoverage=True /property:CoverletOutputFormat=opencover

      - name: Process dotnet test results and create a status check
        id: dotnet_test_check
        uses: im-open/process-dotnet-test-results@v1.0.2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          timezone: 'america/denver'
          create-status-check: true
          create-pr-comment: false

      - name: Generate dotnet Code Coverage Artifacts and Summary
        uses: im-open/code-coverage-report-generator@4.8.13
        with:
          reports: '*/**/coverage.opencover.xml'
          targetdir: ${{ env.CODE_COVERAGE_DIR_DOTNET }}
          title: ${{ env.CODE_COVERAGE_REPORT_NAME_DOTNET }}
          tag: 'Workflow: ${{ github.workflow }} <br/> Run Number: ${{ github.run_number }} <br/> Run ID: ${{ github.run_id }}' #TODO;  Verify the tag to add
          # TODO:  Add the appropriate filters to each type.
          # The filters are a ; separated list of items to include(+) or exclude(-).  Wildcards are accepted.
          # For instance: -xunit*;-Dapper;-*.Tests
          assemblyfilters: ''
          filefilters: ''
          classfilters: ''

      - name: Process dotnet code coverage results and create a status check
        id: dotnet_coverage_check
        uses: im-open/process-code-coverage-summary@v1.0.2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          summary-file: '${{ env.CODE_COVERAGE_DIR_DOTNET }}/Summary.md'
          report-name: ${{ env.CODE_COVERAGE_REPORT_NAME_DOTNET }}
          check-name: ${{ env.CODE_COVERAGE_CHECK_NAME_DOTNET }}
          create-status-check: true
          create-pr-comment: false
          # TODO:  Set the thresholds for branch and line coverage.
          # When set to 0 the outcome is neutral.  Otherwise line/branch coverage will be a 'failure' if actual coverage < threshold.
          line-threshold: 0
          branch-threshold: 0

      - name: Upload dotnet code coverage report
        uses: actions/upload-artifact@v2
        with:
          name: ${{ env.CODE_COVERAGE_REPORT_NAME_DOTNET }}
          path: ${{ env.CODE_COVERAGE_DIR_DOTNET }}

  jest:
    runs-on: [self-hosted, ubuntu-20.04]

    needs: [triggers]
    if: needs.triggers.outputs.CONTINUE_WORKFLOW == 'true'

    defaults:
      run:
        shell: bash

    outputs:
      coverage: ${{ steps.jest_coverage_check.outputs.coverage-outcome }}
      test: ${{ steps.jest_test_check.outputs.test-outcome }}

    steps:
      - uses: actions/checkout@v2

      - name: Setup .NET Core
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      # TODO:  If you are using any nuget/npm packages from GitHub Packages uncomment this step
      # TODO:  If the project contains a local nuget.config, this action will not work properly.  Either:
      #        - Remove the file and use this action or
      #        - Delete this action and modify the file so it has the appropriate org entries in nuget.config. https://github.com/im-practices/git-er-done/blob/main/packages/connect-nuget.md#script-output
      # - name: Authenticate with GitHub Packages
      #   uses: im-open/authenticate-with-gh-package-registries@v1.0.1
      #   with:
      #     read-pkg-token: ${{ secrets.READ_PKG_TOKEN }} # This is an org-level secret
      #     orgs: '' # TODO:  Add a csv list of organizations that npm/nuget packages will be pulled from like 'im-enrollment,im-client'

      - name: dotnet build
        run: dotnet build ${{ env.SOLUTION_FILE }} --configuration Release

      - name: jest test with Coverage
        continue-on-error: true
        working-directory: ${{ env.JEST_TEST_DIR }}
        # TODO:  If you want to use the npm step (npm run test:coverage), it needs to be updated to output a results file, otherwise use the jest command directly
        run: jest --config ./jest.config.js --coverage --json --outputFile=${{ env.JEST_TEST_RESULTS_FILE }}

      - name: Process jest test results and create a status check
        id: jest_test_check
        uses: im-open/process-jest-test-results@v1.0.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          timezone: 'america/denver'
          results-file: ${{ env.JEST_TEST_DIR }}/${{ env.JEST_TEST_RESULTS_FILE }}
          report-name: ${{ env.JEST_TEST_REPORT_NAME }}
          create-status-check: true
          create-pr-comment: false

      - name: Generate jest code coverage artifacts and summary
        uses: im-open/code-coverage-report-generator@4.8.13
        with:
          reports: '*/**/lcov.info'
          targetdir: ${{ env.CODE_COVERAGE_DIR_JEST }}
          title: jest code coverage
          tag: 'Workflow: ${{ github.workflow }} <br/> Run Number: ${{ github.run_number }} <br/> Run ID: ${{ github.run_id }}' #TODO;  Verify the tag to add
          # TODO:  Add the appropriate filters to each type.
          # The filters are a ; separated list of items to include(+) or exclude(-).  Wildcards are accepted.
          # For instance: -xunit*;-Dapper;-*.Tests
          assemblyfilters: ''
          filefilters: ''
          classfilters: ''

      - name: Process jest code coverage results and create a status check
        id: jest_coverage_check
        uses: im-open/process-code-coverage-summary@v1.0.2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          summary-file: '${{ env.CODE_COVERAGE_DIR_JEST }}/Summary.md'
          report-name: ${{ env.CODE_COVERAGE_REPORT_NAME_JEST }}
          check-name: ${{ env.CODE_COVERAGE_CHECK_NAME_JEST }}
          create-status-check: true
          create-pr-comment: false
          # TODO:  Set the thresholds for branch and line coverage.
          # When set to 0 the outcome is neutral.  Otherwise line/branch coverage will be a 'failure' if actual coverage < threshold.
          line-threshold: 0
          branch-threshold: 0

      - name: Upload jest code coverage report
        uses: actions/upload-artifact@v2
        with:
          name: ${{ env.CODE_COVERAGE_REPORT_NAME_JEST }}
          path: ${{ env.CODE_COVERAGE_DIR_JEST }}

  validate-sam-yaml:
    runs-on: ubuntu-latest # Force this to run on github-hosted runner by using a tag that does not exist on self-hosted runners

    needs: [triggers]
    if: needs.triggers.outputs.CONTINUE_WORKFLOW == 'true'

    outputs:
      validate: 'Passed'

    steps:
      - uses: actions/checkout@v2

      - name: Validate SAM.yaml
        run: echo "TODO - Implement once the action has been created"

  build-deployment-artifacts:
    runs-on: ubuntu-latest
    needs: [triggers, dotnet-build-and-test, jest, validate-sam-yaml]
    if: needs.triggers.outputs.CONTINUE_WORKFLOW == 'true'

    defaults:
      run:
        shell: bash

    outputs:
      NEXT_VERSION: ${{ env.VERSION }}

    env:
      IS_MERGE_TO_MAIN: ${{ needs.triggers.outputs.IS_MERGE_TO_MAIN }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2
        with:
          fetch-depth: 0

      - name: Build and Publish
        working-directory: ${{ env.PROJECT_ROOT }}
        run: |
          dotnet build --configuration Release
          dotnet publish -c Release -o ./published_app --no-restore

      - name: Zip the published app
        working-directory: ${{ env.PROJECT_ROOT }}
        run: |
          (cd published_app && zip -r ../${{ env.DEPLOY_ZIP }} .)

      - name: Calculate next pre-release version for branches
        if: env.IS_MERGE_TO_MAIN == 'false'
        uses: im-open/git-version-lite@v1.0.0
        with:
          calculate-prerelease-version: true
          branch-name: ${{ github.head_ref }}

      - name: Calculate next release version for merges to main
        if: env.IS_MERGE_TO_MAIN == 'true'
        uses: im-open/git-version-lite@v1.0.0

      - name: Set PRERELEASE to true for branches
        if: env.IS_MERGE_TO_MAIN == 'false'
        run: echo "PRERELEASE=true" >> $GITHUB_ENV

      - name: Set PRERELEASE to false for merges to main
        if: env.IS_MERGE_TO_MAIN == 'true'
        run: echo "PRERELEASE=false" >> $GITHUB_ENV

      # WARNING!!! This will upload the published_app.zip file to the release.  If it contains any sensitive information like in
      # appsettings.json or a web.config, that sensitive info will be available to download by anyone with read access to this repo.
      - name: Create Release with published_artifacts
        id: create_release
        uses: im-open/create-release@v1.0.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          delete-existing-release: true # Handy when you hit 're-run jobs' on a workflow run
          tag-name: ${{ env.VERSION }}
          prerelease: ${{ env.PRERELEASE }}
          asset-path: ${{ env.PROJECT_ROOT }}/${{ env.DEPLOY_ZIP }}
          asset-name: ${{ env.DEPLOY_ZIP }}
          asset-content-type: application/zip

      #TODO:  Remove this step if you want to keep the pre-releases/tags that were generated for each of the branch builds
      - name: Cleanup the branch pre-releases
        if: env.IS_MERGE_TO_MAIN == 'true'
        uses: im-open/delete-prereleases-for-branch@v1.0.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          branch-name: ${{ github.head_ref }}

  finish-build:
    if: always() && needs.triggers.outputs.CONTINUE_WORKFLOW == 'true'
    needs:
      [
        dotnet-build-and-test,
        jest,
        validate-sam-yaml,
        build-deployment-artifacts,
      ]
    runs-on: ubuntu-latest # Force this to run on github-hosted runner by using a tag that does not exist on self-hosted runners
    steps:
      - uses: im-open/workflow-conclusion@v1.0.1
        id: conclusion
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          # TODO:  Determine if there are any additional step outcomes/outputs you want considered
          additional-conclusions: |
            [
              { "name": "dotnet test", "conclusion" : "${{ needs.dotnet-build-and-test.outputs.test }}" },
              { "name": "dotnet coverage", "conclusion" : "${{ needs.dotnet-build-and-test.outputs.coverage }}" },
              { "name": "jest test", "conclusion" : "${{ needs.jest.outputs.test }}" },
              { "name": "jest coverage", "conclusion" : "${{ needs.jest.outputs.coverage }}" },
              { "name": "sam.yaml validation", "conclusion" : "${{ needs.validate-sam-yaml.outputs.validate }}" }
            ]

      # TODO: Remove if you do not want to send teams notifications after each push
      - name: Send Status to Teams
        if: always()
        uses: im-open/post-status-to-teams-action@v1.0.0
        with:
          title: 'CI Build' # TODO:  Verify title
          workflow-status: ${{ steps.conclusion.outputs.workflow_conclusion }}
          workflow-type: Build
          teams-uri: ${{ secrets.MS_TEAMS_URI }} # This is a repo-level secret (unless 'environment:' has been added to the finish-build job)
          timezone: America/Denver # TODO:  Verify timezone
          # TODO:  Verify the custom facts you want included
          custom-facts: |
            [
              { "name": "Event", "value": "${{ github.event_name }}" },
              { "name": "Workflow", "value": "${{ github.workflow }}" },
              { "name": "Run", "value": "${{ github.run_id }}" },
              { "name": "Actor", "value": "${{ github.actor }}" }
            ]
          # TODO:  Verify additional buttons you want included.  A View Build Log is included by default.  If no additional actions are needed, delete this arg.
          custom-actions: |
            [
              { "name": "", "uri": "" }
            ]

      - name: Comment on PR with version ${{ needs.build-deployment-artifacts.outputs.NEXT_VERSION }}
        if: github.event_name == "pull_request"
        uses: actions/github-script@v4
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          script: |
            let nextVersion = '${{ needs.build-deployment-artifacts.outputs.NEXT_VERSION }}';
            let hasRelease = nextVersion && nextVersion.length > 0;
            let releaseText = hasRelease ? '${{ needs.build-deployment-artifacts.outputs.NEXT_VERSION }}](${{ env.REPO_URL }}/releases/${{ needs.build-deployment-artifacts.outputs.NEXT_VERSION }}' : 'N/A';
            const commentBody = `
            - [Workflow Run - ${{ steps.conclusion.outputs.workflow_conclusion }}](${{ env.REPO_URL }}/actions/runs/${{ github.run_id }})
            - [Release - ${releaseText})`;
            github.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });

      - name: Check for Failures
        if: steps.conclusion.outputs.workflow_conclusion == 'failure'
        run: |
          echo "There were errors in the workflow.  Check the workflow-conclusion step above for more details on what failed."
          exit 1
