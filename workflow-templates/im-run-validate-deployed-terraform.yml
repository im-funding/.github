# Workflow Code: ShinySQUIRREL_v1    DO NOT REMOVE

# Pre-requisites
# This workflow relies on a Deployment Board being set up to determine what should be currently deployed to the environment
# https://github.com/im-practices/git-er-done/blob/main/actions/deployment-board.md

name: Validate Deployed Terraform
on:
  schedule:
    # See the following site for help creating the right cron syntax: https://crontab.guru/
    # The cron job is specified in UTC.
    # 05:00 on Monday UTC
    - cron: 0 5 * * 1 #TODO:  Pick a new time to avoid running scheduled scans at the same time as everyone else.

jobs:
  auto-plan-the-tf:
    runs-on: [self-hosted, ubuntu-20.04]

    strategy:
      matrix:
        # TODO: verify the environment you want this workflow to check
        environment: [dev, qa, stage, demo, uat, prod]

    environment: ${{ matrix.environment }}

    env:
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      ARM_ENVIRONMENT: 'public'
      TF_IN_AUTOMATION: 'true'
      TF_VERSION: '~>1.0.5' #TODO:  Verify your version of terraform.
      TF_WORKING_DIR: './${{ matrix.environment }}' # TODO:  Verify this directory structure would be correct for your repository
      REPO_URL: https://github.com/${{ github.repository }}
      # These SSH keys are org level secrets
      SSH_KEY_CENTRAL_LOGGING: ${{ secrets.SSH_CENTRAL_LOGGING }}
      SSH_KEY_STORAGE_ACCOUNT: ${{ secrets.SSH_STORAGE_ACCOUNT }}
      SSH_KEY_NETWORK_INFO: ${{ secrets.SSH_NETWORK_INFO }}
      SSH_KEY_ON_PREM_EGRESS: ${{ secrets.SSH_ON_PREM_EGRESS }} # TODO: SSH_KEY_ON_PREM_EGRESS & its usages can be removed if you've transitioned to storage-account-network-rules v2.0.3 or higher and to network-information instead of on-prem-egress-ips in your tf.

    defaults:
      run:
        shell: bash
        working-directory: '${{ env.TF_WORKING_DIR }}'

    steps:
      - name: Determine latest release
        id: get-latest
        uses: actions/github-script@v4
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let labelName = `??currently-in-${{ matrix.environment }}`;
            try {
              let owner = context.repo.owner;
              let repo = context.repo.repo;

              core.info(`Finding issuess with label '${labelName}'...`);

              const query = `
              query {
                repository(owner: "${owner}", name: "${repo}") {
                  issues(first: 1, filterBy: {labels: ["${labelName}"]}) {
                    edges {
                      node {
                        title
                      }
                    }
                  }
                }
              }`;

              const response = await github.graphql(query);

              if (!response.repository.issues || !response.repository.issues.edges || response.repository.issues.edges.length === 0) {
                core.info(`There were no issues with label '${labelName}'.  Default to checking against main.`);
                core.setOutput('VERSION', 'main');
              }
              else {
                const title = response.repository.issues.edges.map(ri => ri.node.title)[0];
                core.info(`The following issues had label '${labelName}': '${title}'`);
                
                const regex = /(branch|tag|sha) Deploy: /i;
                let version = title.replace(regex, '').trim();
                core.info(`The deployed infrastructure will be compared against ${version}`);
                core.setOutput('VERSION', version);
              }
            } catch (error) {
              core.info(`An error occurred retrieving issues with the '${labelName}' label: ${error}`);
              core.info(`You may need to manually remove the ${labelName} from other issues`);
              core.info('Default to checking tf against main.');
              core.setOutput('VERSION', 'main');
            }

      - name: Checkout Repository
        uses: actions/checkout@v2
        with:
          ref: ${{ steps.get-latest.outputs.VERSION }}

      - name: Setup Terraform
        id: setup
        uses: hashicorp/setup-terraform@v1.2.1
        with:
          terraform_version: '${{ env.TF_VERSION }}'

      # Allows pulling modules from the repo instead of artifactory
      - name: Setup SSH Keys and known_hosts
        uses: im-open/setup-deploy-keys@1.0.1
        with:
          deploy-key-info: |
            [
              { "orgAndRepo": "im-platform/central-logging", "envName" : "SSH_KEY_CENTRAL_LOGGING" },
              { "orgAndRepo": "im-platform/storage-account-network-rules", "envName" : "SSH_KEY_STORAGE_ACCOUNT" },
              { "orgAndRepo": "im-platform/network-information", "envName" : "SSH_KEY_NETWORK_INFO" },
              { "orgAndRepo": "im-platform/on-prem-egress-ips", "envName" : "SSH_KEY_ON_PREM_EGRESS" }
            ]

      - name: Terraform Init
        id: init
        run: terraform init

      # TODO:  Remove the pagerduty token if not configuring pagerduty.  If using pagerduty verify 'pagerduty_token' is the name of the variable that tf expects
      # TODO:  Add any other secrets that would be required for a tf plan to succeed
      # PAGERDUTY_API_KEY is an org level secret
      - name: Terraform Plan
        id: plan
        run: |
          terraform plan -detailed-exitcode \
          -var="pagerduty_token=${{ secrets.PAGERDUTY_API_KEY }}"
        continue-on-error: true

      - name: Trigger PagerDuty
        if: steps.plan.outputs.exitcode == '2'
        uses: im-open/create-pagerduty-incident@v1.0.0
        with:
          pagerduty-api-key: ${{ secrets.PAGERDUTY_API_KEY }}
          service-id: ${{ secrets.PAGERDUTY_SERVICE_ID }} # TODO:  Ensure this secret exists
          email: 'svc-hubot@extendhealth.com'
          title: 'Your terraform does not match what was expected!'
          body: 'The workflow found changes in the ${{matrix.environment}} environment.  The workflow expected the infrastructure to match the terraform at ${{ steps.get-latest.outputs.VERSION }}.  See workflow run at ${{ env.REPO_URL }}/actions/runs/${{ github.run_id }} for more details.'
